{"pages":[{"date":"2024-05-09","image":"","imageAlt":"","link":"https://dev.enthys.com/posts/another_one/","summary":"This is a page which might contains something very useful for people.","tags":["one"],"text":"this is a page which might contains something very useful for people.\n","title":"Another example page"},{"date":"2024-05-09","image":"","imageAlt":"","link":"https://dev.enthys.com/projects/example/","summary":"This is an example project post ","tags":["introduction","project"],"text":"this is an example project post ","title":"This is the first project of many"},{"date":"2024-05-09","image":"","imageAlt":"","link":"https://dev.enthys.com/posts/hello-world/","summary":"Creating the coolest blog ever! What will it be about though? This blog can be about many things, like:\nHow to work with different technologies, like Git, Golang, Godot, other things which start with G. How to resolve issues Step by step guide to doing something ","tags":["one","three","two"],"text":"creating the coolest blog ever! what will it be about though? this blog can be about many things, like:\nhow to work with different technologies, like git, golang, godot, other things which start with g. how to resolve issues step by step guide to doing something ","title":"Hello, World!"},{"date":"2024-05-09","image":"","imageAlt":"","link":"https://dev.enthys.com/posts/obsidian_git_android/","summary":"How to setup Obsidian on your android tablet and have your notes saved on Github Hello there this is a post on how to do things","tags":["one","two"],"text":"how to setup obsidian on your android tablet and have your notes saved on github hello there this is a post on how to do things\n","title":"Obsidian on Android with Github backups"},{"date":"2024-05-09","image":"","imageAlt":"","link":"https://dev.enthys.com/about/","summary":"Hello! My name is Asen Mihaylov, I am a Software Developer from Bulgaria.","tags":[],"text":"hello! my name is asen mihaylov, i am a software developer from bulgaria.\n","title":"About me"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://dev.enthys.com/posts/golang_json_dynamic_array_types/","summary":"How to parse an array which contains dynamic types Parsing an array which has a single type within it is easy, but what about arrays which have dynamic values? Parsing such arrays could be tricky but in this post we will explore how to do just that. Lets imagine we are making a game and we have an array or nearby targets, each one having different attributes based on the type of nearby target.\nOur array { \u0026#34;targets\u0026#34;: [ {\u0026#34;type\u0026#34;: \u0026#34;player\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 10, \u0026#34;name\u0026#34;: \u0026#34;Duke\u0026#34;, \u0026#34;class\u0026#34;: \u0026#34;Warrior\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;enemy\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 11, \u0026#34;name\u0026#34;: \u0026#34;Goblin\u0026#34;, \u0026#34;personality\u0026#34;: \u0026#34;aggressive\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Tree\u0026#34;, interactable\u0026#34;: false }} ] } In the JSON above we have an array which has 3 items in it.","tags":["golang"],"text":"how to parse an array which contains dynamic types parsing an array which has a single type within it is easy, but what about arrays which have dynamic values? parsing such arrays could be tricky but in this post we will explore how to do just that. lets imagine we are making a game and we have an array or nearby targets, each one having different attributes based on the type of nearby target.\nour array { \u0026#34;targets\u0026#34;: [ {\u0026#34;type\u0026#34;: \u0026#34;player\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 10, \u0026#34;name\u0026#34;: \u0026#34;duke\u0026#34;, \u0026#34;class\u0026#34;: \u0026#34;warrior\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;enemy\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 11, \u0026#34;name\u0026#34;: \u0026#34;goblin\u0026#34;, \u0026#34;personality\u0026#34;: \u0026#34;aggressive\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;tree\u0026#34;, interactable\u0026#34;: false }} ] } in the json above we have an array which has 3 items in it. each item represents a different kind of targets which our player can do things with.\nparsing the array types lets first create our classes\ntype player struct { level int `json:\u0026#34;level\u0026#34;` name string `json:\u0026#34;name\u0026#34;` class string `json:\u0026#34;class\u0026#34;` } type enemy struct { level int `json:\u0026#34;level\u0026#34;` name string `json:\u0026#34;name\u0026#34;` personality string `json:\u0026#34;personality\u0026#34;` } type object struct { name string `json:\u0026#34;name\u0026#34;` interactable bool `json:\u0026#34;interactable\u0026#34;` } each of our classes now can be used to parse their own individual json string, but when they are all in an array it won\u0026rsquo;t really work. lets make our lives a bit easier and make an interface which all of our types will implement.\ntype named interface { getname() string } func (p player) getname() string { return p.name } func (e enemy) getname() string { return g.name } func (o object) getname() string { return o.name } lets start parsing now that we have an interface which all of our types implement. we can create an array which uses that interface. but still how do we parse the values? the way we can parse the json is a combination of anonymous structs and json.rawmessage. lets start unmarshaling\nfunc main() { j := []byte(`{ \u0026#34;targets\u0026#34;: [ {\u0026#34;type\u0026#34;: \u0026#34;player\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 10, \u0026#34;name\u0026#34;: \u0026#34;duke\u0026#34;, \u0026#34;class\u0026#34;: \u0026#34;warrior\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;enemy\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;level\u0026#34;: 11, \u0026#34;name\u0026#34;: \u0026#34;goblin\u0026#34;, \u0026#34;personality\u0026#34;: \u0026#34;aggressive\u0026#34;}}, {\u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;attributes\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;tree\u0026#34;, \u0026#34;interactable\u0026#34;: false }} ] }`) var nameabletargets struct{ targets []named // our end goal is to fill this array } var targets struct{ targets []struct{ // depending on the value of this field we will be determining what kind of struct we should initiate type string `json:\u0026#34;type\u0026#34;` // by using rawmessage we can delay the parsing of the values in order to determine what kind of type to use arguments json.rawmessage `json:\u0026#34;attributes\u0026#34;` } } // parse the json into our temporary collection if err := json.unmarshal(j, \u0026amp;targets); err != nil { panic(err) } // fill out the result array with the correct types for _, t := range targets.targets { switch t.type { case \u0026#34;player\u0026#34;: var player player if err := json.unmarshal(t, \u0026amp;player); err != nil { panic(err) } nameabletargets = append(nameabletargets, player) case \u0026#34;enemy\u0026#34;: var enemy enemy if err := json.unmarshal(t, \u0026amp;enemy); err != nil { panic(err) } nameabletargets = append(nameabletargets, enemy) case \u0026#34;object\u0026#34;: var obj object if err := json.unmarshal(t, \u0026amp;object); err != nil { panic(err) } nameabletargets = append(nameabletargets, obj) } } fmt.printf(\u0026#34;%+v\u0026#34;, nameabletargets) } and that is the way we can dynamically determine what kind of object should be created and saved to the array.\n","title":"How to parse an array with differing array types"}]}